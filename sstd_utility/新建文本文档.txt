namespace sstd {

    template<typename ...T>
    class class_wrap {
    public:
        constexpr static inline std::size_t size() { return sizeof...(T); }
    };

    template<>
    class class_wrap<void> {
    public:
        constexpr static inline std::size_t size() { return 0; }
    };

    template<typename T> class get_first;
    template<template<typename ...> class A, typename ATF, typename ATS, typename ... AT>
    class get_first< A< ATF, ATS, AT ...> > {
    public:
        using first_type = ATF;
        using second_type = ATS;
        using tail = class_wrap<ATS, AT...>;
        constexpr const static bool has_first = true;
        constexpr const static bool has_second = true;
    };

    template<template<typename > class A, typename ATF>
    class get_first< A<ATF> > {
    public:
        using first_type = ATF;
        using second_type = void;
        using tail = class_wrap<void>;
        constexpr const static bool has_first = true;
        constexpr const static bool has_second = false;
    };

    template<template<typename > class A >
    class get_first< A<void> > {
    public:
        using first_type = void;
        using second_type = void;
        using tail = class_wrap<void>;
        constexpr const static bool has_first = false;
        constexpr const static bool has_second = false;
    };

    template<std::size_t, typename > class get_from_index;

    template<template<typename ...> class A, typename ... AT  >
    class get_from_index<0, A<AT...>> {
    public:
        using type = typename get_first<A<AT...>>::first_type;
    };

    template<std::size_t N, template<typename ...> class A, typename ... AT  >
    class get_from_index<N, A<AT...>> {
        using tail = typename get_first<A<AT...>>::tail;
        static_assert(N < (sizeof...(AT)), "N out of index");
    public:
        using type = typename get_from_index<N - 1, tail>::type;
    };

    template<typename, typename > class has_class;

    template<template<typename > class A, typename AT, typename B>
    class has_class< A<AT>, B > {
    public:
        const constexpr static bool value = std::is_same_v<AT, B>;
    };

    template<template<typename ... > class A, typename AT0, typename AT1, typename ... AT, typename B>
    class has_class<A<AT0, AT1, AT...>, B> {
        using tail = typename get_first< A< AT0, AT1, AT... > >::tail;
    public:
        const constexpr static bool value = std::is_same_v<AT0, B> || has_class<tail, B>::value;
    };

    template<typename, typename> class unique_append;
    template<template <typename ...> class  A, typename ... AT, typename B>
    class unique_append<A<AT...>, B> {
    public:
        using type = std::conditional_t<has_class<A<AT...>, B>::value, class_wrap<AT...>, class_wrap<AT..., B> >;
    };

    template<template <typename ...> class  A, typename ... AT >
    class unique_append<A<AT...>, void> {
    public:
        using type = class_wrap<AT...>;
    };

    template<typename>
    class unique;

    namespace _private {
        template<typename, typename>
        class unique_detail;

        template<template<typename ...> class A, typename ... AT,
            template<typename > class B, typename BT >
        class unique_detail<A<AT...>, B<BT>> {
        public:
            using type = typename unique_append<A<AT...>, BT>::type;
        };

        template<template<typename ...> class A, typename ... AT,
            template<typename ... > class B, typename BT0, typename BT1, typename ... BT >
        class unique_detail<A<AT...>, B<BT0, BT1, BT...>> {
            using type0 = typename unique_append<A<AT...>, BT0>::type;
        public:
            using type = typename unique_detail<type0, class_wrap<BT1, BT...>>::type;
        };

    }/*_private*/

    template<template<typename> class T, typename T0>
    class unique<T<T0>> {
    public:
        using type = class_wrap<T0>;
    };

    template<template<typename...> class T, typename T0, typename T1, typename ... TT>
    class unique<T<T0, T1, TT...>> {
    public:
        using type = typename get_first<
            typename _private::unique_detail<
            class_wrap<void>, class_wrap<T0, T1, TT...> >::type >::tail;
    };

    namespace _private {
        template<typename T1, typename T2>
        class cat2;

        template<template<typename ...> class A, template<typename ...> class B, typename ... AT, typename ... BT>
        class cat2<A<AT ...>, B<BT ...>> {
        public:
            using type = class_wrap< AT ..., BT ... >;
        };
    }/*_private*/

    template<typename ... > class cat;

    template<template<typename ...> class A, typename ... T>
    class cat<A<T...>> {
    public:
        using type = class_wrap<T...>;
    };

    template<template<typename ...> class A0, typename ...T0,
        template<typename ...> class A1, typename ...T1 >
    class cat<A0<T0...>, A1<T1...>> {
    public:
        using type = typename _private::cat2< class_wrap<T0...>, class_wrap<T1...> >::type;
    };

    template<typename T1, typename T2, typename T3, typename ... T>
    class cat<T1, T2, T3, T...> {
    public:
        using type = typename cat< typename cat<T1, T2>::type, typename cat<T3, T...>::type >::type;
    };

    template<typename ... T>
    class unique_cat {
        using cat_type = typename cat<T...>::type;
    public:
        using type = typename unique<cat_type>::type;
    };


}/*namespace sstd*/













